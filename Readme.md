# Test Dataset
- test_data.txt 官网给的，数据量较少，mini版
- test_data_2.txt 自己生成的，数据量达到280w,为了方便看到结果对不对，所以是直接复制几份test_data.txt得到的数
- test_data_3.txt 按照其他算法随机生成的280w数据量，result3.txt 就是对应的answer


# Algorithm
- Main345.py 
    - 使用circle保存了已经成环的路径，比如2-1-4-3-2形成一个环，则circle[2]=[1,4,3],circle[1]=[4,3,2],circle[4]=[3,2,1],circle[3]=[2,1,4]
    那么下一次访问到2,1,4,3中的任意一个点后，可以直接将路径加上去即可return
    - 对于只有入度或者只有出度的点不被访问，可以直接pass
    - 在访问的过程中，如果退栈之后可以将该点的出度全部删除，以防下一次再次访问，比如访问的栈为[2,1,4,3]访问完了3之后，从3回退到4时，可以将3的出度全部删除，之所以可以这样做，是因为3回退回去之后表明3的出度已经全部访问完了，无需第二次访问，这也就可以避免重复环路的出现
    - 出现的问题是当深度很大时，会爆栈，提交出现RE
    - 因为题目要求的是3-7的环路长度即可，所以走到7步之后可以停止了，所以就在走到7步之后就回退，但是这种情况下不会删除这条回退回去的边，从其他路回退的边可以删除，如果从其父节点再回退时也不会删除边，因为下次还需要访问这个点
    并且对所有点都尝试一次遍历，只需要该点的存在出度且存在入度即可


- Main.py 
    - 参考CodeCraft2020_v3.py的三领域方法，从该点的入度和出度分别走三步即可，找出领域，然后对该点走最多七步找到环路
    - 本想可以将环路存储路径的方法加进去，但是还没有实现成功，最后提交时间是33s
